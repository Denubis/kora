<?php namespace App;

use App\Http\Controllers\RecordController;
use App\KoraFields\AssociatorField;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\HasOne;
use Illuminate\Support\Facades\DB;

class Record extends Model {

    /*
    |--------------------------------------------------------------------------
    | Record
    |--------------------------------------------------------------------------
    |
    | This model represents the data for a Record
    |
    */

    /**
     * @var array - Attributes that can be mass assigned to model
     */
    protected $fillable = [
        'kid',
        'legacy_kid',
        'project_id',
        'form_id',
        'owner'
    ];

    public function __construct(array $attributes = array(), $fid = null) {
        parent::__construct($attributes);
        $this->table = "records_$fid";
    }

    public function getTable() {
        //The second case is where we make a new model. The constructor has built the table for us
        //The first case is where we pull Record objs from the DB, they don't pass in a Form ID, but since they exist,
            //we will just use the one assigned to the data.

        if($this->table=='records_')
            return 'records_'.$this->form_id;
        else
            return parent::getTable(); // TODO: Change the autogenerated stub
    }

    /**
     * Returns the form associated with a Record.
     *
     * @return BelongsTo
     */
    public function form() {
        return $this->belongsTo('App\Form', 'form_id');
    }

    /**
     * Returns the owner associated with a Record.
     *
     * @return HasOne
     */
    public function owner() {
        return $this->hasOne('App\User', 'owner');
    }

    /**
     * Deletes all data fields belonging to a record, then deletes self.
     */
    public function delete() {
        //Delete reverse associations for everyone's sake
        DB::table(AssociatorField::Reverse_Cache_Table)
            ->where('associated_kid','=',$this->kid)
            ->orWhere('source_kid','=',$this->kid)
            ->delete();

        //Delete images
        $storageType = 'LaravelStorage'; //TODO:: make this a config once we actually support other storage types
        switch($storageType) {
            case 'LaravelStorage':
                $filePath = storage_path('app/files/' . $this->project_id . '/' . $this->form_id . '/' . $this->id);
                if(file_exists($filePath)) {
                    //empty path files, revisions already saved these files in case things go wrong
                    foreach(new \DirectoryIterator($filePath) as $file) {
                        if($file->isFile())
                            unlink($filePath . '/' . $file->getFilename());
                    }
                }
                break;
            default:
                break;
        }

        parent::delete();
    }

    /**
     * Determines if the record is a record preset.
     *
     * @return bool - Is a preset
     */
    public function isPreset() {
        return (RecordPreset::where('record_kid',$this->kid)->count()>0);
    }

    /**
     * Determines if a string is a KID pattern.
     * For reference, the KID pattern is PID-FID-RID, i.e. three sets of integers separated by hyphens.
     *
     * @param $string - Kora ID to validate
     * @return bool - Matches pattern
     */
    public static function isKIDPattern($string) {
        $pattern = "/^([0-9]+)-([0-9]+)-([0-9]+)/"; // Match exactly with KID pattern.
        return preg_match($pattern, $string) != false;
    }

    /**
     * Gets a list of records that associate to this record
     *
     * @return array - Records that associate it
     */
    public function getAssociatedRecords() {
        $assoc = DB::table(AssociatorField::Reverse_Cache_Table)
            ->distinct()
            ->where('associated_kid','=',$this->kid)->get();

        $records = array();
        foreach($assoc as $af) {
            $kid = $af->source_kid;
            $rec = RecordController::getRecord($kid);
            array_push($records,$rec);
        }

        return $records;
    }

    /**
     * Builds the hashed file data array for the record.
     *
     * @return array - The file data for DB storage
     */
    public function getHashedRecordFiles() {
        $hashArray = [];

        $storageType = 'LaravelStorage'; //TODO:: make this a config once we actually support other storage types
        switch($storageType) {
            case 'LaravelStorage':
                $dir = storage_path('app/files/'.$this->project_id.'/'.$this->form_id.'/'.$this->id);
                if(file_exists($dir)) {
                    foreach(new \DirectoryIterator($dir) as $file) {
                        if($file->isFile()) {
                            $name = $file->getFilename();
                            $data = file_get_contents("$dir/$name");
                            $hashArray[$name] = gzcompress($data,9);
                        }
                    }
                }
                break;
            default:
                break;
        }

        return $hashArray;
    }

    /**
     * Gets a preview value for the record when displaying in a reverse association.
     *
     * @return string - The preview value
     */
    public function getReversePreview() {
        $form = $this->form()->first();
        $fields = $form->layout['fields'];

        $preview = 'No Preview Field Available';
        foreach($fields as $flid => $field) {
            //Can this field be previewed?
            if(!in_array($field['type'],Form::$validAssocFields))
                continue;
            //Is there data in this record?
            if(is_null($this->{$flid}))
                continue;

            $preview = $this->{$flid};
        }

        return $preview;
    }
}

